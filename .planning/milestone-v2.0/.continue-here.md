---
milestone: v2.0 In-Browser Audio Processing
phase: 6 (Foundation & Configuration)
status: milestone_initialized
last_updated: 2026-01-26T00:00:00Z
---

<current_state>
Milestone v2.0 "In-Browser Audio Processing" has been fully initialized and is ready to begin execution.

**What was accomplished this session:**
- Updated PROJECT.md with v2.0 goals (browser-based FFmpeg processing)
- Completed research (4 parallel researchers + synthesizer)
- Defined 9 requirements across 3 categories (FFmpeg Integration, Audio Processing, Export Enhancement)
- Created roadmap with 5 phases (6-10)
- All artifacts committed

**Current position:**
- At the start of Phase 6 (Foundation & Configuration)
- No plans created yet
- Ready to begin `/gsd:plan-phase 6`
</current_state>

<milestone_context>

**V2.0 Goals:**
Add browser-based audio processing using FFmpeg.wasm to:
- Apply marked cut regions to remove sections
- Generate processed audio file in browser
- Download edited audio without external scripts

**User Choices Made:**
- Browser-based processing (not server-based) via FFmpeg.wasm
- Remove marked regions (not keep-only workflow)
- Manual trigger for processing (not automatic preview)
- Minimal v2.0 scope: core processing + download only
- Deferred: progress indication, cancel button, format preservation, memory cleanup, error handling

**Technology Stack:**
- FFmpeg.wasm 0.12.15 with multi-threaded core (@ffmpeg/core-mt)
- Vite migration required for COOP/COEP headers (SharedArrayBuffer support)
- Processing time: 3-6 minutes for 90-minute podcasts
- Memory usage: 150-400 MB peak (well within 2GB limit)

</milestone_context>

<v2.0_requirements>

**9 requirements across 3 categories:**

### FFmpeg Integration
- FFMPEG-01: System loads FFmpeg.wasm library on demand
- FFMPEG-02: System integrates FFmpeg.wasm with existing audio playback architecture

### Audio Processing
- PROC-01: System applies marked cut regions to remove sections
- PROC-02: System generates processed audio file in browser memory
- PROC-03: System constructs FFmpeg filter commands from cut point data
- PROC-04: System handles 45-90 minute podcast files during processing

### Export Enhancement
- EXPORT-03: User can trigger audio processing from UI ("Export Edited Audio" button)
- EXPORT-04: User can download processed audio file via browser download
- EXPORT-05: System suggests sensible filename for downloaded audio

</v2.0_requirements>

<roadmap_structure>

**5 phases for v2.0 (continues from v1.0 phase 5):**

1. **Phase 6: Foundation & Configuration** (FFMPEG-01)
   - Configure Vite with COOP/COEP headers
   - Load FFmpeg.wasm library
   - Browser compatibility detection
   - File size validation

2. **Phase 7: Core FFmpeg.wasm Processing** (FFMPEG-02, PROC-01-04)
   - ProcessingService implementation
   - FFmpeg filter_complex command construction
   - Apply cuts to audio
   - Generate output file

3. **Phase 8: Service Integration & Download** (EXPORT-03-05)
   - Wire to existing services (AudioService, CutController, ExportService)
   - Add "Export Edited Audio" button
   - Browser download with filename suggestion

4. **Phase 9: Error Handling & Polish**
   - Memory error handling
   - Cancel button
   - Progress indication
   - Processing time estimates

5. **Phase 10: UAT & Browser Compatibility**
   - Test on Chrome, Firefox, Edge
   - iOS Safari single-thread fallback
   - Large file validation (45-90 min)
   - Memory leak detection

</roadmap_structure>

<research_highlights>

**Key Findings from Research:**

**Critical Success Factors:**
- Multi-threaded core provides 2x speedup (essential for 45-90 min podcasts)
- Vite migration is BLOCKING requirement (COOP/COEP headers needed for SharedArrayBuffer)
- File size <100 MB safe limit (2GB WebAssembly hard limit)

**Major Risks Identified:**
1. Memory exhaustion with large files (>100 MB can hit 2GB limit)
2. Cross-origin isolation headers REQUIRED for multi-threading
3. iOS Safari lacks SharedArrayBuffer (needs single-thread fallback, 2x slower)
4. Progress events unreliable (use indeterminate spinner)
5. Virtual filesystem memory leaks (explicit cleanup critical)
6. FFmpeg.wasm load time: 10-30 seconds first use

**Architecture Pattern:**
- New ProcessingService with lazy loading
- Extend AudioService for getOriginalFile() method
- Extend ExportService for downloadAudio() method
- Filter_complex commands to build audio segments
- Aggressive memory cleanup (unlink + exit after operation)

**Research files available:**
- `.planning/research/STACK.md` - FFmpeg.wasm 0.12.15 integration
- `.planning/research/FEATURES.md` - UX patterns and feature priorities
- `.planning/research/ARCHITECTURE.md` - Service integration patterns
- `.planning/research/PITFALLS.md` - 7 critical pitfalls with prevention strategies
- `.planning/research/SUMMARY.md` - Executive summary and roadmap implications

</research_highlights>

<decisions_made>

**Scope Decisions:**
- V2.0 focuses on core processing capability only
- Progress indication, cancel, format preservation â†’ v2.x (deferred)
- No server-based processing (browser-only preserves privacy)
- No real-time preview (doubles memory usage)

**Technical Decisions:**
- Use FFmpeg.wasm 0.12.15 with multi-threaded core
- Migrate from `serve` to Vite dev server (enables COOP/COEP)
- Lazy load FFmpeg.wasm (not at startup)
- Build filter_complex commands to remove cut regions

**UX Decisions:**
- Manual trigger via "Export Edited Audio" button
- Indeterminate progress indicator (FFmpeg progress events unreliable)
- Suggested filename format: original_edited_timestamp.mp3

</decisions_made>

<next_actions>

**Immediate next step:**

```bash
/gsd:plan-phase 6
```

This will:
1. Create detailed execution plan for Phase 6 (Foundation & Configuration)
2. Break down Vite migration, FFmpeg.wasm loading, header configuration
3. Define tasks for browser compatibility detection and file size validation
4. Consider research insights about cross-origin isolation requirements

**Alternative (if want to discuss first):**

```bash
/gsd:discuss-phase 6
```

Gather additional context through conversation before planning.

**What Phase 6 should deliver:**
- Vite dev server replacing `serve` package
- vite.config.js with COOP/COEP headers configured
- FFmpeg.wasm @ffmpeg/ffmpeg and @ffmpeg/util packages installed
- ProcessingService skeleton with lazy loading pattern
- Browser compatibility detection (SharedArrayBuffer support check)
- File size validation before processing (<50-100 MB warning)

**Success criteria for Phase 6:**
1. User can run app with Vite dev server
2. User can verify COOP/COEP headers active in browser console
3. User can load FFmpeg.wasm without SharedArrayBuffer errors
4. User sees clear error if browser lacks WebAssembly/SharedArrayBuffer
5. User sees file size warning if audio exceeds 50 MB

</next_actions>

<files_to_review>

**Project documentation:**
- `.planning/PROJECT.md` - Updated with v2.0 milestone goals
- `.planning/REQUIREMENTS.md` - 9 v2.0 requirements defined
- `.planning/ROADMAP.md` - 5 phases (6-10) with success criteria
- `.planning/STATE.md` - Current position and metrics
- `.planning/research/SUMMARY.md` - Research synthesis

**Existing codebase (v1.0):**
- `src/services/AudioService.js` - HTML5 Audio streaming (will extend)
- `src/services/TranscriptionService.js` - Whisper API integration
- `src/services/ExportService.js` - JSON export (will extend for audio)
- `src/controllers/CutController.js` - Cut region management
- `src/controllers/PlayerController.js` - Playback controls
- `src/controllers/TranscriptController.js` - Navigation

**To be created in Phase 6:**
- `vite.config.js` - COOP/COEP headers
- `src/services/ProcessingService.js` - FFmpeg.wasm wrapper
- Browser compatibility detection logic
- File size validation logic

</files_to_review>

<context_for_resumption>

**Mental model:**

V1.0 built a complete podcast editor that outputs JSON cut lists for external ffmpeg scripts. V2.0 brings FFmpeg into the browser via WebAssembly, eliminating the need for external processing.

The architecture is clean: v1.0 already has all the infrastructure (audio loading, transcription, cut marking). V2.0 adds ONE new service (ProcessingService) and extends two existing services (AudioService, ExportService).

The roadmap follows dependency order:
1. First get FFmpeg.wasm working (Phase 6)
2. Then implement core processing (Phase 7)
3. Then wire to UI (Phase 8)
4. Then polish (Phase 9)
5. Then validate across browsers (Phase 10)

Phase 6 is the foundation phase. It's about configuration and setup, NOT about actual processing. The goal is to get FFmpeg.wasm loaded in the browser without errors. This requires:
- Vite (not serve) for header control
- COOP/COEP headers for SharedArrayBuffer
- Proper npm packages installed
- Basic detection/validation logic

Research revealed Phase 6 is CRITICAL and BLOCKING. If cross-origin isolation headers aren't configured correctly, nothing else works. iOS Safari detection is also important early since it needs different code path.

**Vibe:**

This is a focused, well-researched milestone. The research phase uncovered all the major pitfalls. The scope is deliberately minimal (core processing only). The architecture is clean (one new service). The phases follow natural boundaries.

Phase 6 should be straightforward - it's mostly configuration and setup. The hard parts come in Phase 7 (FFmpeg command construction) and Phase 9 (error handling).

**Key insight from research:**

The #1 mistake people make with FFmpeg.wasm is trying to use it like native FFmpeg. The browser environment has different constraints (memory limits, header requirements, codec support). The research documents all these gotchas. Read PITFALLS.md before planning Phase 7.

</context_for_resumption>

<uncommitted_changes>

None - all work committed.

**Commits this session:**
- 77570ac: docs: start milestone v2.0 In-Browser Audio Processing
- c0f245e: docs(research): complete v2.0 FFmpeg.wasm research
- a2082d0: docs: define milestone v2.0 requirements
- a994c3a: docs: create milestone v2.0 roadmap (5 phases)

</uncommitted_changes>
