---
phase: 12-transcript-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - index.html
autonomous: true

must_haves:
  truths:
    - "User can type search text and see matching words highlighted in transcript"
    - "Search highlighting updates in real-time as user types"
    - "Search highlights remain visible on words inside cut regions"
    - "User can clear search highlights using clear button"
    - "Search performs responsively on large transcripts without lag"
  artifacts:
    - path: "package.json"
      provides: "mark.js dependency"
      contains: "mark.js"
    - path: "index.html"
      provides: "Search UI with input and clear button"
      contains: "search-input"
    - path: "index.html"
      provides: "SearchController class"
      min_lines: 80
    - path: "index.html"
      provides: "CSS for search highlights with specificity hierarchy"
      contains: ".search-highlight"
  key_links:
    - from: "SearchController"
      to: "mark.js library"
      via: "Mark instance with transcriptContainer context"
      pattern: "new Mark\\(.*transcriptContainer"
    - from: "search-input element"
      to: "SearchController.onSearchInput"
      via: "input event listener with debouncing"
      pattern: "addEventListener\\('input'"
    - from: "SearchController.mark()"
      to: "mark.js mark() method"
      via: "search term and className option"
      pattern: "this\\.markInstance\\.mark\\("
    - from: "CSS .search-highlight"
      to: "CSS .in-cut-region"
      via: "specificity hierarchy to prevent conflicts"
      pattern: "\\.search-highlight.*\\.in-cut-region"
---

<objective>
Add real-time transcript search with mark.js highlighting that coexists with cut region visual feedback.

Purpose: Enable users to quickly find specific words or phrases in transcript to mark for removal, improving editing workflow efficiency for long podcast transcripts.

Output: Functional search input with real-time highlighting, clear button, and CSS specificity hierarchy that prevents conflicts with cut region styling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

# Phase 11 established cut region highlighting
@.planning/phases/11-cut-region-visual-highlighting/11-01-SUMMARY.md

# Current transcript controller implementation
@src/controllers/transcriptController.js

# Main HTML file for UI and inline controllers
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install mark.js and add search UI</name>
  <files>package.json, index.html</files>
  <action>
Install mark.js library:
- Run `npm install mark.js --save-dev`
- Verify package.json has mark.js dependency

Add search UI to index.html:
- Locate the transcript section (between transcription and transcript-container)
- Add search input container with:
  - Text input field with id="search-input", placeholder="Search transcript..."
  - Clear button with id="search-clear-button", text "Clear"
  - Container div with id="search-container" wrapping both elements
- Style search container to match existing card sections:
  - Use CSS Custom Properties from Phase 10 dark theme
  - Input: --bg-input background, --text-primary color, --border-color border
  - Clear button: Use existing button baseline styles from Phase 11
  - Flexbox layout: input grows (flex: 1), button fixed width
  - Match padding/margin of other card sections

Create SearchController class skeleton in index.html <script type="module">:
- Class structure with constructor accepting elements object and transcriptController
- Properties: searchInput, clearButton, transcriptContainer, transcriptController, markInstance, debounceTimeout
- Methods (stubs): onSearchInput(), performSearch(), clearSearch(), cleanup()
- Import mark.js using ESM syntax: `import Mark from './node_modules/mark.js/dist/mark.es6.min.js'`
- Note: Use mark.es6.min.js (not mark.es6.js - minified version for production)

Wire SearchController in index.html initialization:
- Create SearchController instance after TranscriptController
- Pass DOM element references and transcriptController instance
- Store in window scope for debugging access
  </action>
  <verify>
Run `npm list mark.js` to confirm installation.
Open index.html in browser DevTools:
- Verify search input and clear button render
- Verify SearchController instance exists in window scope
- Check console for any import errors
  </verify>
  <done>
mark.js appears in package.json dependencies.
Search UI renders with input field and clear button in transcript section.
SearchController instantiates without errors.
Browser console shows no import or syntax errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement search highlighting with mark.js integration</name>
  <files>index.html</files>
  <action>
Implement SearchController methods in index.html:

**constructor:**
- Store element references and transcriptController
- Initialize Mark instance: `this.markInstance = new Mark(this.transcriptContainer)`
- Bind event listeners:
  - searchInput 'input' event → this.onSearchInput (debounced)
  - clearButton 'click' event → this.clearSearch

**onSearchInput():**
- Implement 300ms debouncing using clearTimeout/setTimeout pattern
- Clear previous debounce timeout if exists
- Set new timeout to call performSearch() after 300ms
- Reason for debounce: Prevents mark.js from re-running on every keystroke, improves performance on large transcripts

**performSearch():**
- Get search term from input value, trim whitespace
- If search term empty: call clearSearch() and return
- Call markInstance.unmark() with callback to ensure cleanup before new search
- In unmark callback: call markInstance.mark(searchTerm, options)
- mark() options object:
  - `className: "search-highlight"` (custom class for styling)
  - `separateWordSearch: false` (match exact phrase, not individual words)
  - `accuracy: "partially"` (match partial words for flexibility)
  - `caseSensitive: false` (case-insensitive search by default)
- Important: Always unmark() before mark() to prevent duplicate highlights

**clearSearch():**
- Clear input field value
- Call markInstance.unmark() to remove all search highlights
- Clear debounce timeout if pending

**cleanup():**
- Call markInstance.unmark() to remove highlights
- Clear debounce timeout
- Remove event listeners

Add CSS for search highlights with specificity hierarchy:
- Locate CSS Custom Properties section in index.html <style>
- Add light theme search highlight colors:
  - `--search-highlight-bg: #ffeb3b` (bright yellow)
  - `--search-highlight-color: #000000` (black text for contrast)
- Add dark theme search highlight colors in [data-theme="dark"]:
  - `--search-highlight-bg: #f59e0b` (amber/orange)
  - `--search-highlight-color: #1a1a1a` (dark text for contrast)
- Add search highlight class styling in main CSS:
  ```css
  /* Search highlighting - higher specificity than cut regions */
  mark.search-highlight {
    background-color: var(--search-highlight-bg);
    color: var(--search-highlight-color);
    padding: 2px 0;
    border-radius: 2px;
  }

  /* Search highlight on cut regions - both classes visible */
  .transcript-word.in-cut-region mark.search-highlight {
    /* Search highlight takes precedence visually */
    background-color: var(--search-highlight-bg);
    color: var(--search-highlight-color);
    /* Keep cut region border visible for context */
    border-left: 3px solid var(--cut-region-border);
    padding-left: 6px;
    margin-left: 2px;
  }
  ```
- Rationale for CSS specificity: mark.js wraps matched text in `<mark>` tags with className. The `.transcript-word.in-cut-region mark.search-highlight` selector is more specific than `.in-cut-region`, so search highlighting visually dominates while preserving cut region border for context.

**IMPORTANT - Why not use jsonwebtoken pattern here:**
This is NOT a "avoid library X, use library Y" case. mark.js is the standard, mature library for text highlighting with no known compatibility issues. Unlike jsonwebtoken (which had CommonJS issues with Edge Runtime), mark.js is a pure DOM manipulation library with ES6 module support. No alternatives needed.
  </action>
  <verify>
Open browser DevTools:
1. Type search term in input → verify words highlight in real-time after 300ms
2. Type additional characters → verify highlights update (unmark + mark cycle)
3. Mark a cut region → verify cut highlighting appears
4. Search for word inside cut region → verify search highlight shows with cut region border preserved
5. Clear search → verify all search highlights removed, cut regions remain highlighted
6. Check console for any mark.js errors
7. Test on large transcript (>500 words) → verify no lag or freezing during search
  </verify>
  <done>
Search input highlights matching words in transcript as user types.
Search highlights update in real-time with 300ms debounce.
Search highlights remain visible on words inside cut regions (with both visual styles present).
Clear button removes all search highlights.
CSS specificity hierarchy prevents conflicts between search and cut region highlighting.
No console errors from mark.js integration.
Performance remains responsive on large transcripts.
  </done>
</task>

</tasks>

<verification>
**Functional Verification:**
1. Search for word that appears multiple times → all instances highlighted
2. Search for phrase → exact phrase highlighted (not individual words)
3. Search for partial word → matching words highlighted
4. Mark cut region containing search term → both cut highlighting and search highlighting visible
5. Clear search → search highlights removed, cut highlighting preserved
6. Delete cut region → cut highlighting removed, search highlighting preserved (if active)

**Visual Verification:**
7. Search highlights use bright yellow (light theme) or amber (dark theme)
8. Search highlights have sufficient contrast (WCAG AA)
9. Search highlights on cut regions show both search background and cut region border
10. Search UI matches existing card section styling

**Performance Verification:**
11. Type rapidly in search input → only one search executes after typing stops (debouncing works)
12. Search on transcript with 500+ words → highlights appear within 500ms
13. Clear search on large transcript → highlights remove within 100ms

**Requirements Coverage:**
- [x] NAV-01: User can search transcript with text input
- [x] NAV-02: Search highlights all matching words in real-time as user types
- [x] NAV-03: Search highlighting remains visible on cut regions
- [x] NAV-04: Search input has clear/reset functionality
</verification>

<success_criteria>
Phase 12 complete when:
- User can type search term and see all matching words highlighted in transcript
- Search highlighting updates in real-time as user types (with 300ms debounce)
- Search highlights coexist with cut region highlighting without visual conflicts
- Clear button removes all search highlights
- Performance remains responsive on large transcripts (60-90 minute podcasts)
- All 4 Phase 12 requirements (NAV-01 through NAV-04) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/12-transcript-search/12-01-SUMMARY.md` following summary template structure.
</output>
