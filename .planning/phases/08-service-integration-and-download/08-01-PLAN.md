---
phase: 08-service-integration-and-download
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
autonomous: true

must_haves:
  truths:
    - "User can click 'Export Edited Audio' button to trigger processing"
    - "User sees progress indicator during processing (loading, processing stages)"
    - "User receives browser download of processed audio when complete"
    - "User sees filename in format originalname_edited_timestamp.mp3"
    - "Processing errors display clear user-friendly messages"
  artifacts:
    - path: "index.html"
      provides: "Export Edited Audio button, processing progress UI, download trigger"
      contains: "export-audio-btn"
  key_links:
    - from: "index.html (export-audio-btn click)"
      to: "AudioProcessingService.processAudio()"
      via: "click handler calling processAudio with file, cuts, duration"
      pattern: "audioProcessingService\\.processAudio"
    - from: "AudioProcessingService.processAudio() result"
      to: "browser download"
      via: "blob URL creation and anchor click"
      pattern: "URL\\.createObjectURL.*download"
---

<objective>
Wire AudioProcessingService to UI with export button, progress display, and download trigger

Purpose: Complete Phase 8 by integrating the FFmpeg processing pipeline (built in Phase 7) with the UI, enabling users to export edited audio files directly from the browser.

Output: Working "Export Edited Audio" button that processes cuts and triggers download
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-core-ffmpeg-wasm-processing/07-01-SUMMARY.md
@.planning/phases/07-core-ffmpeg-wasm-processing/07-02-SUMMARY.md
@src/services/audioProcessingService.js
@src/services/exportService.js
@src/controllers/cutController.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Export Audio Button and Processing Pipeline Integration</name>
  <files>index.html</files>
  <action>
In index.html, add UI elements and wire processing:

1. Add CSS for export audio button (style like export-btn but with distinct color #6f42c1 purple):
   - #export-audio-btn with same sizing as #export-btn
   - .processing class for disabled state during processing

2. Add button in .export-controls div (after #export-btn):
   ```html
   <button id="export-audio-btn" disabled>Export Edited Audio</button>
   ```

3. In script section, add imports for AudioProcessingService:
   ```javascript
   import AudioProcessingService from './src/services/audioProcessingService.js';
   ```

4. Add DOM reference:
   ```javascript
   exportAudioBtn: document.getElementById('export-audio-btn')
   ```

5. Initialize AudioProcessingService after browserCompat:
   ```javascript
   const audioProcessingService = new AudioProcessingService(browserCompat);
   ```

6. Store current file reference for processing (after file load succeeds):
   ```javascript
   let currentFile = null;
   // In file input handler, after audioService.loadFile succeeds:
   currentFile = file;
   ```

7. Wire export audio button click handler:
   ```javascript
   elements.exportAudioBtn.addEventListener('click', async () => {
     // Get cuts and validate
     const cuts = cutController.getCutRegions();
     if (cuts.length === 0) {
       elements.processingStatus.textContent = 'No cuts to apply';
       elements.processingStatus.style.display = 'block';
       return;
     }

     // Get duration from audioService
     const duration = audioService.getDuration();
     if (!duration || duration <= 0) {
       elements.processingStatus.textContent = 'Audio not loaded';
       elements.processingStatus.style.display = 'block';
       return;
     }

     // Validate file size for processing
     const validation = validateForProcessing(currentFile);
     if (!validation.valid) {
       elements.processingStatus.textContent = validation.errors[0];
       elements.processingStatus.style.display = 'block';
       elements.processingStatus.style.background = '#f8d7da';
       elements.processingStatus.style.borderColor = '#dc3545';
       elements.processingStatus.style.color = '#721c24';
       return;
     }

     // Disable buttons during processing
     elements.exportBtn.disabled = true;
     elements.exportAudioBtn.disabled = true;

     // Show processing status
     elements.processingStatus.style.display = 'block';
     elements.processingStatus.style.background = '#e7f3ff';
     elements.processingStatus.style.borderColor = '#007bff';
     elements.processingStatus.style.color = '#004085';
     elements.processingStatus.textContent = 'Preparing...';

     // Progress callback
     const onProgress = (progress) => {
       if (progress.stage === 'loading') {
         elements.processingStatus.textContent = `Loading FFmpeg: ${progress.progress}%`;
       } else if (progress.stage === 'processing') {
         elements.processingStatus.textContent = `Processing audio: ${progress.progress}%`;
       } else if (progress.stage === 'complete') {
         elements.processingStatus.textContent = 'Preparing download...';
       }
     };

     try {
       // Process audio
       const result = await audioProcessingService.processAudio(
         currentFile,
         cuts,
         duration,
         onProgress
       );

       // Generate filename: originalname_edited_YYYYMMDD_HHMMSS.ext
       const now = new Date();
       const timestamp = now.toISOString().replace(/[-:]/g, '').replace('T', '_').slice(0, 15);
       const baseName = currentFile.name.replace(/\.[^.]+$/, '');
       const extension = currentFile.name.split('.').pop();
       const downloadFilename = `${baseName}_edited_${timestamp}.${extension}`;

       // Create blob and trigger download
       const blob = new Blob([result.data], { type: result.mimeType || 'audio/mpeg' });
       const url = URL.createObjectURL(blob);
       const anchor = document.createElement('a');
       anchor.href = url;
       anchor.download = downloadFilename;
       anchor.style.display = 'none';
       document.body.appendChild(anchor);
       anchor.click();
       document.body.removeChild(anchor);

       // Revoke URL after brief delay to ensure download starts
       setTimeout(() => URL.revokeObjectURL(url), 1000);

       // Show success
       elements.processingStatus.textContent = `Download started: ${downloadFilename}`;
       elements.processingStatus.style.background = '#d4edda';
       elements.processingStatus.style.borderColor = '#28a745';
       elements.processingStatus.style.color = '#155724';

     } catch (error) {
       // Show error
       elements.processingStatus.textContent = error.message;
       elements.processingStatus.style.background = '#f8d7da';
       elements.processingStatus.style.borderColor = '#dc3545';
       elements.processingStatus.style.color = '#721c24';
     } finally {
       // Re-enable buttons
       const hasCuts = cutController.getCutRegions().length > 0;
       elements.exportBtn.disabled = !hasCuts;
       elements.exportAudioBtn.disabled = !hasCuts;
     }
   });
   ```

8. Update cutController.onCutListChanged to also enable/disable exportAudioBtn:
   ```javascript
   cutController.onCutListChanged = (cuts) => {
     renderCutList(cuts);
     if (transcriptController && transcriptController.transcript) {
       transcriptController.highlightCutRegions(cuts);
     }
     const hasCuts = cuts.length > 0;
     elements.exportBtn.disabled = !hasCuts;
     elements.exportAudioBtn.disabled = !hasCuts;
   };
   ```

Note: Keep existing code structure. Add new code alongside existing handlers. Do not modify existing functionality.
  </action>
  <verify>
1. Run `npx vite` to start dev server
2. Open http://localhost:5173 in browser
3. Verify "Export Edited Audio" button appears below "Export Cuts" button (initially disabled)
4. Load an audio file (any small MP3)
5. Mark at least one cut region (Mark Start, then Mark End)
6. Verify both export buttons become enabled
7. Click "Export Edited Audio" button
8. Verify progress status shows "Loading FFmpeg: X%" then "Processing audio: X%"
9. Verify download prompt appears with filename format: originalname_edited_YYYYMMDD_HHMMSS.mp3
10. Verify download completes and file is playable
  </verify>
  <done>
- "Export Edited Audio" button visible and enabled when cuts exist
- Clicking button shows progress updates during processing
- Successful processing triggers browser download
- Downloaded file has correct name format (baseName_edited_timestamp.extension)
- Errors display clear messages in processing status area
  </done>
</task>

</tasks>

<verification>
End-to-end test:
1. Start dev server: `npx vite`
2. Open app in browser
3. Upload test audio file (any MP3)
4. Generate or skip transcript (not required for export)
5. Mark 2-3 cut regions at different timestamps
6. Click "Export Edited Audio"
7. Observe: Progress updates (loading -> processing -> preparing download)
8. Observe: Download prompt with filename matching pattern
9. Verify downloaded audio plays correctly and is shorter than original (cuts removed)

Error handling test:
1. Try export with no cuts marked - should show "No cuts to apply"
2. Try export before audio loaded - should show "Audio not loaded"
</verification>

<success_criteria>
- [ ] Export Edited Audio button appears in export-controls section
- [ ] Button disabled until cuts exist AND audio loaded
- [ ] Processing shows progress stages (loading, processing, complete)
- [ ] Download triggers with correct filename format
- [ ] Downloaded audio plays correctly with cuts removed
- [ ] Error states display clearly
- [ ] Buttons re-enable after processing completes (success or error)
</success_criteria>

<output>
After completion, create `.planning/phases/08-service-integration-and-download/08-01-SUMMARY.md`
</output>
