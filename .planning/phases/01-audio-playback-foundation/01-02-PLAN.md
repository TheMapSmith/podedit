---
phase: 01-audio-playback-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - index.html
  - src/components/playerController.js
autonomous: true

must_haves:
  truths:
    - "User can play audio by clicking play button"
    - "User can pause audio by clicking pause button (same button toggles)"
    - "User can seek to any position by dragging slider"
    - "Current time updates smoothly during playback (60fps via requestAnimationFrame)"
    - "Slider does not jump back while user is dragging it"
    - "Audio continues from seek position after seeking"
  artifacts:
    - path: "src/components/playerController.js"
      provides: "UI controller connecting DOM to AudioService"
      exports: ["PlayerController"]
    - path: "index.html"
      provides: "Complete interactive audio player UI"
      contains: "playerController"
  key_links:
    - from: "src/components/playerController.js"
      to: "src/services/audioService.js"
      via: "play/pause/seek method calls"
      pattern: "audioService\\.(play|pause|seek)"
    - from: "src/components/playerController.js"
      to: "requestAnimationFrame"
      via: "smooth playback position updates"
      pattern: "requestAnimationFrame"
---

<objective>
Complete the audio player UI with full playback controls and smooth interaction.

Purpose: Deliver working play/pause/seek functionality that feels responsive and handles user interaction correctly (no slider jumping, smooth updates, proper autoplay policy handling).

Output:
- PlayerController class managing UI state and audio service interaction
- Fully interactive audio player that meets all Phase 1 success criteria
- Handles autoplay blocking gracefully with user feedback
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audio-playback-foundation/01-RESEARCH.md
@.planning/phases/01-audio-playback-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlayerController class</name>
  <files>
    - src/components/playerController.js
  </files>
  <action>
Create directory `src/components/` if needed.

Create `src/components/playerController.js` with PlayerController class:

Constructor(audioService, elements):
- Takes AudioService instance and object with DOM element references:
  - playButton, seekSlider, currentTimeDisplay, durationDisplay, errorDisplay
- Store references
- Initialize state: isPlaying = false, isSeeking = false, animationFrame = null
- Call setupEventListeners()

Private method setupEventListeners():
- playButton click -> togglePlayback()
- seekSlider 'input' event -> onSeekInput() (fires while dragging)
- seekSlider 'change' event -> onSeekChange() (fires when released)
- audioService.on('ended') -> onPlaybackEnded()
- audioService.on('error') -> onPlaybackError()

Method togglePlayback():
- If playing: pause, update button text to "Play", stop animation loop
- If paused: try to play (await), catch NotAllowedError and show message in errorDisplay, update button text to "Pause", start animation loop

Method onSeekInput(event):
- Set isSeeking = true
- Update currentTimeDisplay with formatTime(slider value)
- Do NOT update audio.currentTime yet (prevents jitter)

Method onSeekChange(event):
- Set isSeeking = false
- Call audioService.seek(parseInt(event.target.value))

Method startUpdating():
- Call updatePlaybackPosition() to begin animation loop

Method stopUpdating():
- cancelAnimationFrame if animationFrame exists
- Set animationFrame = null

Method updatePlaybackPosition():
- If NOT isSeeking:
  - Get currentTime from audioService
  - Update seekSlider.value
  - Update currentTimeDisplay with formatTime
- Request next frame: animationFrame = requestAnimationFrame(() => this.updatePlaybackPosition())

Method onPlaybackEnded():
- Set isPlaying = false
- Update button text to "Play"
- Call stopUpdating()

Method onPlaybackError(error):
- Display error message in errorDisplay
- Log to console for debugging

Method onFileLoaded(duration):
- Set seekSlider.max = Math.floor(duration)
- Update durationDisplay with formatTime(duration)
- Enable playButton and seekSlider (remove disabled attribute)
- Reset seekSlider.value to 0
- Reset currentTimeDisplay to "0:00"

Method cleanup():
- Call stopUpdating()
- Call audioService.cleanup()

Export default PlayerController.

Key patterns from research:
- Use 'input' for drag tracking, 'change' for actual seek
- Check isSeeking flag before updating slider in animation loop
- Handle NotAllowedError for autoplay policy
  </action>
  <verify>
Test in browser console after loading a file:
```javascript
// After file loads:
// Click play - button should change to "Pause", audio should play
// Click pause - button should change to "Play", audio should pause
// Drag slider - time display should update while dragging
// Release slider - audio should seek to that position
```
  </verify>
  <done>
- Play button starts playback and changes to "Pause"
- Pause button stops playback and changes to "Play"
- Time display updates smoothly during playback (no visible jitter)
- Slider can be dragged without jumping back
- Releasing slider seeks audio to that position
- Audio ended event resets UI to initial state
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire up complete player in index.html</name>
  <files>
    - index.html
  </files>
  <action>
Update the script section in index.html to:

1. Import PlayerController from './src/components/playerController.js'

2. Create DOM element references object:
```javascript
const elements = {
  fileInput: document.getElementById('file-input'),
  fileInfo: document.getElementById('file-info'),
  playerControls: document.getElementById('player-controls'),
  playButton: document.getElementById('play-button'),
  seekSlider: document.getElementById('seek-slider'),
  currentTimeDisplay: document.getElementById('current-time'),
  durationDisplay: document.getElementById('duration'),
  errorDisplay: document.getElementById('error')
};
```

3. Initialize AudioService and PlayerController:
```javascript
const audioService = new AudioService();
const playerController = new PlayerController(audioService, elements);
```

4. Update file input handler to:
- Clear any previous errors
- Validate file with validateAudioFile
- If invalid: show errors in errorDisplay, return early
- Call audioService.loadFile(file)
- On success:
  - Show file info (name, formatted size)
  - Show player controls container
  - Call playerController.onFileLoaded(result.duration)
- On error: show error message

5. Add cleanup on page unload:
```javascript
window.addEventListener('beforeunload', () => {
  playerController.cleanup();
});
```

6. Update CSS to style:
- Controls container with flex layout
- Play button with clear hover/active states
- Disabled state for button and slider (grayed out)
- Seek slider taking remaining width (flex: 1)
- Time displays on same line as slider or below
- Error text in red
  </action>
  <verify>
Complete end-to-end test:
1. Open http://localhost:8000
2. Page loads, only file input visible
3. Upload MP3 file - file info shows, player appears
4. Click Play - audio plays, button shows "Pause", time updates
5. Click Pause - audio pauses, button shows "Play"
6. Drag slider - time display updates during drag
7. Release slider - audio seeks, continues from new position
8. Let audio play to end - UI resets to "Play" button
9. Upload new file - old file cleaned up, new file ready
  </verify>
  <done>
- File upload triggers validation and loading
- Player controls appear after successful load
- Play/pause toggle works correctly
- Seek slider responds to user input without jumping
- Time display updates smoothly during playback
- Error messages display for invalid files or playback errors
- Loading new file cleans up previous file
  </done>
</task>

<task type="auto">
  <name>Task 3: Test with large podcast file and verify memory efficiency</name>
  <files>
    (No file changes - testing task)
  </files>
  <action>
This is a verification task to ensure the implementation handles large files correctly.

Test procedure:
1. Find or download a 60-90 minute podcast MP3 file (typically 50-100MB)
   - Example sources: any podcast RSS feed, Internet Archive
   - If no large file available, test with largest available file

2. Open DevTools Memory tab before loading file
   - Take initial heap snapshot

3. Load the large file via file input
   - Observe: file should load within a few seconds
   - Duration should display correctly

4. Take another heap snapshot
   - Memory increase should be ~50-100MB, NOT 500-600MB
   - Look for blob: URLs - should see exactly 1

5. Test playback:
   - Play for 30 seconds
   - Seek to middle of file
   - Playback should continue without delay
   - No audio stuttering

6. Test seek accuracy:
   - Seek to 30:00
   - Note actual position (may be off by 1-2 seconds for VBR MP3)
   - This is expected behavior documented in research

7. Load a second file
   - Memory should NOT double
   - Previous blob: URL should be revoked
   - Heap snapshot should show similar memory as step 4

Document any issues found. If memory is excessive, review audioService.js for proper cleanup and preload settings.
  </action>
  <verify>
Manual verification:
- Large file (60+ min) loads in <5 seconds
- Memory usage stays under 150MB total
- Seek works throughout entire file
- No browser crash or freeze
- Loading second file doesn't accumulate memory
  </verify>
  <done>
- 60+ minute podcast loads successfully
- Memory usage reasonable (under 150MB)
- Playback works throughout file length
- Seek to any position works (within VBR accuracy limits)
- No memory leaks when loading multiple files
- Browser remains responsive throughout testing
  </done>
</task>

</tasks>

<verification>
Complete Phase 1 verification against success criteria:

1. "User can upload a 60-minute podcast MP3 file and see it loaded in the app"
   - Upload 60-min MP3 -> file info displays, duration shows correctly

2. "User can play/pause audio using on-screen controls"
   - Click Play -> audio plays, button shows Pause
   - Click Pause -> audio pauses, button shows Play

3. "User can seek to any position in the audio timeline and playback continues from that point"
   - Drag slider to middle -> release -> audio plays from new position
   - Time display shows correct position after seek

4. "User can see current playback position and total duration"
   - During playback, current time updates every frame (smooth)
   - Total duration shows when file loads

5. "User can upload and play a 90-minute podcast without browser memory crash or degraded performance"
   - Test with largest available file
   - Memory stays reasonable
   - No freezing or crashing
   - Playback is smooth
</verification>

<success_criteria>
- All 5 phase success criteria are met
- Play/pause works correctly
- Seek slider is smooth and responsive (no jumping during drag)
- Time display updates at 60fps during playback
- Large files stream efficiently (memory under 150MB)
- No memory leaks when loading multiple files
- Autoplay blocking handled gracefully with user message
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-playback-foundation/01-02-SUMMARY.md`

Document:
- Implementation details
- Any deviations from plan
- Test results with large files
- Phase 1 completion status

Also update `.planning/STATE.md` to reflect Phase 1 completion.
</output>
