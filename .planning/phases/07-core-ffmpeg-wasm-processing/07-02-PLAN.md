---
phase: 07-core-ffmpeg-wasm-processing
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified: [src/services/audioProcessingService.js]
autonomous: true

must_haves:
  truths:
    - "Service can write audio file bytes to FFmpeg virtual filesystem"
    - "Service can execute FFmpeg command to apply cuts and produce output"
    - "Service can read output file from virtual filesystem as Uint8Array"
    - "Service cleans up virtual filesystem after processing (no memory leaks)"
    - "Output audio duration matches expected duration within 0.5 second tolerance"
  artifacts:
    - path: "src/services/audioProcessingService.js"
      provides: "Complete audio processing pipeline"
      exports: ["default (AudioProcessingService class)"]
      min_lines: 150
  key_links:
    - from: "src/services/audioProcessingService.js"
      to: "FFmpeg virtual filesystem"
      via: "ffmpeg.writeFile, ffmpeg.readFile, ffmpeg.deleteFile"
      pattern: "this\\.ffmpeg\\.(writeFile|readFile|deleteFile)"
---

<objective>
Add file I/O and processing execution to AudioProcessingService

Purpose: Complete the processing pipeline by adding methods to write input audio to FFmpeg's virtual filesystem, execute the filter command, read the output, and clean up. This enables actual audio processing in the browser.

Output: AudioProcessingService.processAudio() method that takes a File and cut regions, runs FFmpeg, and returns processed audio bytes with proper memory cleanup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-ffmpeg-wasm-processing/07-01-PLAN.md

# Code from Plan 01
@src/services/audioProcessingService.js
@src/services/browserCompatibility.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add virtual filesystem operations and processAudio method</name>
  <files>src/services/audioProcessingService.js</files>
  <action>
Add the main processing method to AudioProcessingService:

1. Add async processAudio(file, cutRegions, totalDuration, onProgress) method:

   a. Validate inputs:
      - cutRegions must be array with at least one complete cut
      - totalDuration must be positive number
      - If no valid cuts, throw Error('No cuts to apply')

   b. Ensure FFmpeg loaded:
      - Call await this.ensureFFmpegLoaded(onProgress)
      - onProgress callback receives { stage: 'loading'|'processing'|'complete', progress: 0-100 }

   c. Write input file to virtual filesystem:
      - Convert File to Uint8Array: new Uint8Array(await file.arrayBuffer())
      - Determine input filename from file.name or use 'input.mp3'
      - Call await this.ffmpeg.writeFile(inputFilename, inputData)
      - Report progress: { stage: 'processing', progress: 10 }

   d. Build FFmpeg command:
      - Call buildFilterCommand(cutRegions, totalDuration)
      - If useDirectCopy is true, throw Error('No cuts to apply - use direct copy')

   e. Determine output filename:
      - Use same extension as input (preserve format)
      - Pattern: 'output.{ext}'

   f. Execute FFmpeg:
      - Build args array: ['-i', inputFilename, '-filter_complex', filterComplex, '-map', '[out]', outputFilename]
      - Call await this.ffmpeg.exec(args)
      - Report progress: { stage: 'processing', progress: 80 }

   g. Read output file:
      - Call await this.ffmpeg.readFile(outputFilename)
      - Returns Uint8Array

   h. Cleanup virtual filesystem (CRITICAL for memory):
      - await this.ffmpeg.deleteFile(inputFilename)
      - await this.ffmpeg.deleteFile(outputFilename)
      - Wrap cleanup in try/catch to not fail if files don't exist

   i. Report complete and return:
      - { stage: 'complete', progress: 100 }
      - Return { data: outputData, mimeType: file.type, filename: outputFilename }

2. Add private _getFileExtension(filename) helper:
   - Extract extension from filename
   - Default to 'mp3' if no extension

Error handling:
- Wrap entire process in try/catch
- On error, still attempt cleanup
- Re-throw with descriptive message: 'Audio processing failed: {original message}'
  </action>
  <verify>
Code review verification (cannot test FFmpeg execution in Node.js):
```
node -e "
import AudioProcessingService from './src/services/audioProcessingService.js';

// Verify method exists and has correct signature
const proto = AudioProcessingService.prototype;
if (typeof proto.processAudio !== 'function') throw new Error('processAudio method missing');

// Check it's async
const fnString = proto.processAudio.toString();
if (!fnString.includes('async')) throw new Error('processAudio should be async');

// Check it uses ffmpeg methods
const serviceCode = await import('fs').then(fs => fs.readFileSync('./src/services/audioProcessingService.js', 'utf-8'));
if (!serviceCode.includes('writeFile')) throw new Error('Missing writeFile call');
if (!serviceCode.includes('readFile')) throw new Error('Missing readFile call');
if (!serviceCode.includes('deleteFile')) throw new Error('Missing deleteFile call (cleanup)');
if (!serviceCode.includes('exec')) throw new Error('Missing exec call');

console.log('PASS: processAudio method structure verified');
"
```
  </verify>
  <done>processAudio() method implemented with file I/O, FFmpeg execution, and cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Add output verification and robust error handling</name>
  <files>src/services/audioProcessingService.js</files>
  <action>
Enhance processAudio with output verification:

1. Add async verifyOutputDuration(outputData, expectedDuration, tolerance = 0.5) method:
   - This is a placeholder that returns { valid: true, actualDuration: null, message: 'Duration verification requires browser playback' }
   - Full verification will happen in Phase 8 when we have browser context
   - The tolerance parameter (default 0.5 seconds) stored for later use

2. Update processAudio to return verification info:
   - Calculate expectedDuration using getExpectedOutputDuration()
   - Return object includes: { data, mimeType, filename, expectedDuration }

3. Add robust error handling for FFmpeg failures:
   - Common FFmpeg.wasm errors to catch:
     * "Exit code: 1" - general failure, often invalid filter
     * Memory allocation failures
     * Invalid input format
   - Map to user-friendly messages:
     * "FFmpeg processing failed. The audio file may be corrupted or in an unsupported format."
     * "Out of memory. Try processing a smaller file."

4. Add cleanup guarantee with finally block:
   - Move cleanup to finally {} block
   - Track which files were written (inputWritten, outputWritten flags)
   - Only delete files that were successfully written
   - Log cleanup errors but don't throw

5. Add FFmpeg log capture for debugging:
   - Store recent log messages in this.lastLogs = []
   - Limit to last 50 messages
   - Include in error messages when processing fails

Export remains as default class.
  </action>
  <verify>
Code review verification:
```
node -e "
import AudioProcessingService from './src/services/audioProcessingService.js';

// Verify verifyOutputDuration exists
const proto = AudioProcessingService.prototype;
if (typeof proto.verifyOutputDuration !== 'function') throw new Error('verifyOutputDuration missing');

// Check code for finally block and error handling
const serviceCode = await import('fs').then(fs => fs.readFileSync('./src/services/audioProcessingService.js', 'utf-8'));

if (!serviceCode.includes('finally')) throw new Error('Missing finally block for cleanup guarantee');
if (!serviceCode.includes('expectedDuration')) throw new Error('Missing expectedDuration in return');
if (!serviceCode.includes('lastLogs') || !serviceCode.includes('log')) throw new Error('Missing log capture');

console.log('PASS: Error handling and verification structure verified');
"
```
  </verify>
  <done>processAudio returns expectedDuration, has robust error handling with finally-block cleanup, and captures FFmpeg logs</done>
</task>

<task type="auto">
  <name>Task 3: Add progress callbacks for long-running operations</name>
  <files>src/services/audioProcessingService.js</files>
  <action>
Enhance progress reporting throughout the processing pipeline:

1. Update FFmpeg log handler to estimate progress:
   - FFmpeg logs include "time=" indicating encoding progress
   - Parse time from log messages: match /time=(\d+):(\d+):(\d+\.\d+)/
   - Convert to seconds and calculate percentage: (currentTime / totalDuration) * 100
   - Call onProgress({ stage: 'processing', progress: calculated, time: currentTime })

2. Add progress stages with meaningful percentages:
   - 0-10%: Loading FFmpeg (if not already loaded)
   - 10-15%: Writing input file
   - 15-90%: FFmpeg processing (derived from time= logs)
   - 90-95%: Reading output file
   - 95-100%: Cleanup and finalization

3. Update ensureFFmpegLoaded to pass through progress:
   - Remap BrowserCompatibility progress (0-100) to our 0-10% range
   - { stage: 'loading', progress: Math.floor(bcProgress.progress / 10) }

4. Add timeout protection:
   - Default timeout: 10 minutes (600000ms)
   - Configurable via constructor: new AudioProcessingService(bc, { timeout: 600000 })
   - If processing exceeds timeout, attempt cleanup and throw TimeoutError

5. Store processing state for potential cancellation (Phase 9):
   - this.isProcessing = false
   - Set to true at start, false at end (in finally)
   - Add isProcessing() getter method
  </action>
  <verify>
Code review verification:
```
node -e "
import AudioProcessingService from './src/services/audioProcessingService.js';
import BrowserCompatibility from './src/services/browserCompatibility.js';

// Test constructor accepts options
const bc = new BrowserCompatibility();
const service = new AudioProcessingService(bc, { timeout: 300000 });

// Verify isProcessing method exists
if (typeof service.isProcessing !== 'function') throw new Error('isProcessing getter missing');

// Check code for progress parsing
const serviceCode = await import('fs').then(fs => fs.readFileSync('./src/services/audioProcessingService.js', 'utf-8'));

if (!serviceCode.includes('time=')) throw new Error('Missing time= parsing for progress');
if (!serviceCode.includes('timeout')) throw new Error('Missing timeout handling');

console.log('PASS: Progress callbacks and timeout handling verified');
"
```
  </verify>
  <done>processAudio reports granular progress derived from FFmpeg time= logs, has timeout protection, and tracks processing state</done>
</task>

</tasks>

<verification>
1. processAudio() accepts File, cutRegions, totalDuration, onProgress
2. Input file written to virtual filesystem, output read back
3. Virtual filesystem cleaned up in finally block (no memory leaks)
4. Progress callback receives meaningful stage/progress updates
5. Timeout protection prevents infinite hangs
6. Error messages are user-friendly with FFmpeg logs for debugging
</verification>

<success_criteria>
- processAudio(file, cuts, duration, onProgress) executes FFmpeg and returns { data, mimeType, filename, expectedDuration }
- Virtual filesystem cleanup happens even on error (finally block)
- Progress updates include: loading (0-10%), processing (10-90%), complete (100%)
- Processing timeout configurable, defaults to 10 minutes
- FFmpeg log messages captured and available for debugging
- isProcessing() returns current processing state
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-ffmpeg-wasm-processing/07-02-SUMMARY.md`
</output>
