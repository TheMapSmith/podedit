---
phase: 07-core-ffmpeg-wasm-processing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/services/audioProcessingService.js]
autonomous: true

must_haves:
  truths:
    - "AudioProcessingService can be instantiated and receives BrowserCompatibility instance"
    - "Service can generate FFmpeg filter_complex command from array of cut regions"
    - "Filter command correctly computes KEEP segments (inverse of cut regions)"
    - "Multiple cut regions produce concatenated KEEP segments with atrim filters"
  artifacts:
    - path: "src/services/audioProcessingService.js"
      provides: "FFmpeg command generation and processing orchestration"
      exports: ["default (AudioProcessingService class)"]
      min_lines: 80
  key_links:
    - from: "src/services/audioProcessingService.js"
      to: "src/services/browserCompatibility.js"
      via: "constructor injection"
      pattern: "this\\.browserCompatibility"
---

<objective>
Create AudioProcessingService with FFmpeg filter_complex command generation

Purpose: Build the core service that converts cut regions into FFmpeg filter commands. The filter_complex approach extracts KEEP segments (inverse of cuts) and concatenates them into the output file.

Output: AudioProcessingService class with buildFilterCommand() method that generates correct FFmpeg filter_complex strings from cut region arrays.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation-configuration/06-02-SUMMARY.md

# Existing code to integrate with
@src/services/browserCompatibility.js
@src/models/cutRegion.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AudioProcessingService with constructor and FFmpeg integration</name>
  <files>src/services/audioProcessingService.js</files>
  <action>
Create AudioProcessingService class in src/services/audioProcessingService.js:

1. Constructor accepts BrowserCompatibility instance:
   - Store as this.browserCompatibility
   - Initialize this.ffmpeg = null (will be set when loaded)

2. Add async ensureFFmpegLoaded(onProgress) method:
   - Call this.browserCompatibility.loadFFmpeg(onProgress)
   - Store result in this.ffmpeg
   - Return the ffmpeg instance

3. Add buildFilterCommand(cutRegions, totalDuration) method that:
   - Accepts array of CutRegion objects and total audio duration in seconds
   - Sorts cut regions by startTime
   - Computes KEEP segments (the inverse of cuts):
     * If cuts are [10-20, 30-40] and total is 60, KEEP is [0-10, 20-30, 40-60]
   - Returns object with:
     * filterComplex: string for -filter_complex argument
     * outputCount: number of segments to concatenate

Filter command format for FFmpeg.wasm (audio only):
- Use atrim filter for each KEEP segment: [0:a]atrim=start=0:end=10,asetpts=PTS-STARTPTS[a0]
- Concatenate all segments: [a0][a1][a2]concat=n=3:v=0:a=1[out]
- The asetpts=PTS-STARTPTS resets timestamps after trim (critical for clean concatenation)

Edge cases to handle:
- No cuts: return simple copy command (no filter needed)
- Cut at start: first KEEP segment starts after first cut's end
- Cut at end: last KEEP segment ends at last cut's start
- Adjacent cuts: merge them (no zero-duration KEEP segment)

Export class as default.
  </action>
  <verify>
Node.js validation:
```
node -e "
import AudioProcessingService from './src/services/audioProcessingService.js';
import BrowserCompatibility from './src/services/browserCompatibility.js';

const bc = new BrowserCompatibility();
const service = new AudioProcessingService(bc);

// Test filter command generation
const cuts = [
  { startTime: 10, endTime: 20, isComplete: () => true },
  { startTime: 30, endTime: 40, isComplete: () => true }
];
const result = service.buildFilterCommand(cuts, 60);
console.log('Filter command:', result.filterComplex);
console.log('Segment count:', result.outputCount);

// Should produce 3 KEEP segments: [0-10], [20-30], [40-60]
if (result.outputCount !== 3) throw new Error('Expected 3 segments');
if (!result.filterComplex.includes('atrim')) throw new Error('Missing atrim filter');
console.log('PASS: Filter command generation works');
"
```
  </verify>
  <done>AudioProcessingService exists with buildFilterCommand() generating correct FFmpeg filter_complex commands for cut regions</done>
</task>

<task type="auto">
  <name>Task 2: Add edge case handling and filter optimization</name>
  <files>src/services/audioProcessingService.js</files>
  <action>
Enhance buildFilterCommand() to handle edge cases:

1. No cuts (empty array):
   - Return { filterComplex: null, outputCount: 0, useDirectCopy: true }
   - Caller should use simple copy instead of filter

2. Single KEEP segment (all cuts at edges):
   - If only one segment remains, still use atrim but simpler output
   - Example: cut [0-10] from 60s file = single segment [10-60]

3. Overlapping or adjacent cuts:
   - Add private method _mergeOverlappingCuts(sortedCuts) that:
     * Merges cuts where one ends where another begins (or overlaps)
     * Returns merged array
   - Call this before computing KEEP segments

4. Cut covering entire file:
   - If merged cuts leave no KEEP segments, throw Error('No audio would remain after cuts')

5. Add method getExpectedOutputDuration(cutRegions, totalDuration):
   - Returns expected output duration = totalDuration - sum of cut durations
   - Used for verification after processing

Ensure filter string uses proper escaping:
- No special characters in atrim values (just numbers)
- Stream labels use simple alphanumeric: [a0], [a1], etc.
  </action>
  <verify>
Node.js validation of edge cases:
```
node -e "
import AudioProcessingService from './src/services/audioProcessingService.js';
import BrowserCompatibility from './src/services/browserCompatibility.js';

const bc = new BrowserCompatibility();
const service = new AudioProcessingService(bc);

// Test 1: No cuts
const result1 = service.buildFilterCommand([], 60);
if (!result1.useDirectCopy) throw new Error('Empty cuts should use direct copy');
console.log('PASS: No cuts returns direct copy flag');

// Test 2: Adjacent cuts should merge
const adjacent = [
  { startTime: 10, endTime: 20, isComplete: () => true },
  { startTime: 20, endTime: 30, isComplete: () => true }
];
const result2 = service.buildFilterCommand(adjacent, 60);
// Should produce 2 KEEP segments: [0-10], [30-60] (cuts merged to [10-30])
if (result2.outputCount !== 2) throw new Error('Adjacent cuts should merge');
console.log('PASS: Adjacent cuts merged correctly');

// Test 3: Expected output duration
const cuts = [
  { startTime: 10, endTime: 20, isComplete: () => true },
  { startTime: 30, endTime: 35, isComplete: () => true }
];
const expected = service.getExpectedOutputDuration(cuts, 60);
// 60 - 10 - 5 = 45
if (expected !== 45) throw new Error('Expected duration calculation wrong');
console.log('PASS: Expected output duration calculated correctly');

console.log('All edge cases pass');
"
```
  </verify>
  <done>buildFilterCommand() handles all edge cases (no cuts, adjacent cuts, overlapping cuts) and getExpectedOutputDuration() calculates correct output length</done>
</task>

</tasks>

<verification>
1. Node.js can import AudioProcessingService without errors
2. buildFilterCommand() generates valid filter_complex strings
3. Edge cases handled (empty cuts, adjacent cuts, overlapping cuts)
4. getExpectedOutputDuration() returns correct values
5. Service integrates with BrowserCompatibility via constructor injection
</verification>

<success_criteria>
- AudioProcessingService class exists in src/services/audioProcessingService.js
- buildFilterCommand(cuts, duration) returns { filterComplex, outputCount, useDirectCopy }
- Filter commands use atrim for segments and concat for joining
- getExpectedOutputDuration(cuts, duration) returns total - sum(cut durations)
- All edge cases produce correct output or appropriate errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-ffmpeg-wasm-processing/07-01-SUMMARY.md`
</output>
