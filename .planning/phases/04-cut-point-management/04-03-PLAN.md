---
phase: 04-cut-point-management
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - index.html
autonomous: true

must_haves:
  truths:
    - "User can edit cut region start time by typing directly"
    - "User can edit cut region end time by typing directly"
    - "Edited timestamps update cut region and transcript highlighting"
    - "Invalid timestamps are rejected with validation"
  artifacts:
    - path: "index.html"
      provides: "Editable timestamp inputs in cut list"
      contains: "cut-time-input"
  key_links:
    - from: "index.html"
      to: "src/controllers/cutController.js"
      via: "cutController.updateCut on input change"
      pattern: "cutController\\.updateCut"
---

<objective>
Add inline timestamp editing for cut regions.

Purpose: Allow user to fine-tune cut boundaries by typing exact timestamps directly, without needing to re-mark. Satisfies CUT-04 requirement.

Output: Editable time inputs in cut list that update cut regions and transcript highlighting on change.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-cut-point-management/04-01-PLAN.md
@.planning/phases/04-cut-point-management/04-02-PLAN.md

# Current implementation
@index.html
@src/controllers/cutController.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add editable timestamp inputs to cut list items</name>
  <files>index.html</files>
  <action>
Update the renderCutList function in index.html to use editable inputs instead of static text for timestamps.

1. Add CSS for the timestamp inputs:
```css
.cut-time-input {
  width: 60px;
  padding: 4px 6px;
  font-size: 13px;
  font-family: inherit;
  font-variant-numeric: tabular-nums;
  border: 1px solid #ced4da;
  border-radius: 4px;
  text-align: center;
}

.cut-time-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.cut-time-input.invalid {
  border-color: #dc3545;
  background-color: #fff5f5;
}

.cut-time-separator {
  margin: 0 4px;
  color: #6c757d;
}
```

2. Update renderCutList function to render editable inputs:
```javascript
function renderCutList(cuts) {
  if (cuts.length === 0) {
    elements.cutList.innerHTML = '<p class="cut-placeholder">No cuts marked yet. Use "Mark Start" and "Mark End" to define regions to remove.</p>';
    return;
  }

  elements.cutList.innerHTML = cuts.map((cut, index) => `
    <div class="cut-item" data-cut-id="${cut.id}">
      <div class="cut-item-info">
        <span class="cut-item-label">Cut ${index + 1}:</span>
        <input type="text"
               class="cut-time-input cut-start-input"
               data-cut-id="${cut.id}"
               value="${formatCutTime(cut.startTime)}"
               title="Start time (M:SS or MM:SS)">
        <span class="cut-time-separator">-</span>
        <input type="text"
               class="cut-time-input cut-end-input"
               data-cut-id="${cut.id}"
               value="${formatCutTime(cut.endTime)}"
               title="End time (M:SS or MM:SS)">
      </div>
      <div class="cut-item-actions">
        <button class="cut-item-delete" data-cut-id="${cut.id}">Delete</button>
      </div>
    </div>
  `).join('');

  // Wire delete buttons
  elements.cutList.querySelectorAll('.cut-item-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const cutId = e.target.getAttribute('data-cut-id');
      cutController.deleteCut(cutId);
    });
  });

  // Wire start time inputs
  elements.cutList.querySelectorAll('.cut-start-input').forEach(input => {
    input.addEventListener('change', (e) => {
      handleTimeInputChange(e.target, 'start');
    });
    input.addEventListener('blur', (e) => {
      handleTimeInputChange(e.target, 'start');
    });
  });

  // Wire end time inputs
  elements.cutList.querySelectorAll('.cut-end-input').forEach(input => {
    input.addEventListener('change', (e) => {
      handleTimeInputChange(e.target, 'end');
    });
    input.addEventListener('blur', (e) => {
      handleTimeInputChange(e.target, 'end');
    });
  });
}
```

3. Add time parsing helper function:
```javascript
/**
 * Parse time string to seconds
 * Accepts formats: "M:SS", "MM:SS", "H:MM:SS", or just seconds "123"
 * @param {string} timeStr - Time string to parse
 * @returns {number|null} - Seconds or null if invalid
 */
function parseTimeInput(timeStr) {
  if (!timeStr || typeof timeStr !== 'string') return null;

  const trimmed = timeStr.trim();

  // Try plain number (seconds)
  if (/^\d+(\.\d+)?$/.test(trimmed)) {
    return parseFloat(trimmed);
  }

  // Try M:SS or MM:SS
  const mmss = /^(\d{1,2}):(\d{2})$/.exec(trimmed);
  if (mmss) {
    const mins = parseInt(mmss[1], 10);
    const secs = parseInt(mmss[2], 10);
    if (secs < 60) {
      return mins * 60 + secs;
    }
  }

  // Try H:MM:SS
  const hmmss = /^(\d{1,2}):(\d{2}):(\d{2})$/.exec(trimmed);
  if (hmmss) {
    const hours = parseInt(hmmss[1], 10);
    const mins = parseInt(hmmss[2], 10);
    const secs = parseInt(hmmss[3], 10);
    if (mins < 60 && secs < 60) {
      return hours * 3600 + mins * 60 + secs;
    }
  }

  return null;
}
```

4. Add input change handler:
```javascript
/**
 * Handle time input change for a cut region
 * @param {HTMLInputElement} input - The input element
 * @param {string} field - 'start' or 'end'
 */
function handleTimeInputChange(input, field) {
  const cutId = input.getAttribute('data-cut-id');
  const cut = cutController.getCutRegions().find(c => c.id === cutId);
  if (!cut) return;

  const newTime = parseTimeInput(input.value);

  // Validate parsed time
  if (newTime === null || newTime < 0) {
    input.classList.add('invalid');
    return;
  }

  // Get the other value
  const startTime = field === 'start' ? newTime : cut.startTime;
  const endTime = field === 'end' ? newTime : cut.endTime;

  // Validate start < end
  if (startTime >= endTime) {
    input.classList.add('invalid');
    return;
  }

  // Remove invalid class and update
  input.classList.remove('invalid');
  const success = cutController.updateCut(cutId, startTime, endTime);

  if (!success) {
    input.classList.add('invalid');
  }
}
```
  </action>
  <verify>
Test in browser:
1. Mark a cut region (e.g., 0:30 to 1:15)
2. Click on start time input, change to "0:45" and tab out
3. Observe: cut updates to 0:45 - 1:15, transcript highlighting updates
4. Click on end time input, change to "1:00" and tab out
5. Observe: cut updates to 0:45 - 1:00
6. Try invalid input "abc" - input shows red border
7. Try making start > end (e.g., start=2:00, end=1:00) - shows invalid
  </verify>
  <done>Cut list has editable timestamp inputs that validate and update cut regions on change</done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard support for time editing</name>
  <files>index.html</files>
  <action>
Enhance time inputs with Enter key handling and escape to revert:

Add keydown handlers to time inputs in renderCutList:
```javascript
// After wiring change/blur handlers, add keydown handlers:
elements.cutList.querySelectorAll('.cut-time-input').forEach(input => {
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      input.blur();  // Trigger blur which handles the change
    } else if (e.key === 'Escape') {
      // Revert to original value
      const cutId = input.getAttribute('data-cut-id');
      const cut = cutController.getCutRegions().find(c => c.id === cutId);
      if (cut) {
        const isStart = input.classList.contains('cut-start-input');
        input.value = formatCutTime(isStart ? cut.startTime : cut.endTime);
        input.classList.remove('invalid');
        input.blur();
      }
    }
  });
});
```

This provides:
- Enter: commits the change (by triggering blur)
- Escape: reverts to current stored value and closes edit
  </action>
  <verify>
1. Edit a time input
2. Press Enter - change is applied
3. Edit again, type something, press Escape - reverts to previous value
4. Invalid input shows red, Escape clears invalid state
  </verify>
  <done>Time inputs support Enter to commit and Escape to revert</done>
</task>

</tasks>

<verification>
Full requirement coverage test:
1. Load audio, generate transcript
2. Mark cut from 0:30 to 1:00
3. Edit start to "0:20" - cut updates, transcript highlighting shifts
4. Edit end to "0:50" - cut updates, highlighting adjusts
5. Try "invalid" text - red border, value not saved
6. Try start > end - red border, value not saved
7. Press Escape - reverts to valid value
8. Press Enter - commits valid change
9. Delete cut - removed from list and highlighting cleared
</verification>

<success_criteria>
- User can type directly in start time input (CUT-04)
- User can type directly in end time input (CUT-04)
- Valid formats accepted: M:SS, MM:SS, H:MM:SS
- Invalid inputs show visual feedback (red border)
- Start > end validation prevents invalid state
- Enter commits, Escape reverts
- Transcript highlighting updates when timestamps change
</success_criteria>

<output>
After completion, create `.planning/phases/04-cut-point-management/04-03-SUMMARY.md`
</output>
