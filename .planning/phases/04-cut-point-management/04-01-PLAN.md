---
phase: 04-cut-point-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/cutRegion.js
  - src/controllers/cutController.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "Cut regions can be created with start/end timestamps"
    - "CutController manages array of cut regions"
    - "Cut regions have unique IDs for tracking"
  artifacts:
    - path: "src/models/cutRegion.js"
      provides: "CutRegion data model"
      exports: ["CutRegion"]
    - path: "src/controllers/cutController.js"
      provides: "Cut region state management"
      exports: ["CutController"]
  key_links:
    - from: "src/controllers/cutController.js"
      to: "src/models/cutRegion.js"
      via: "import CutRegion"
      pattern: "import.*CutRegion"
    - from: "index.html"
      to: "src/controllers/cutController.js"
      via: "import CutController"
      pattern: "import CutController"
---

<objective>
Create the data model and controller for managing cut regions.

Purpose: Establish the core data structures and state management that all cut point features depend on. This is the foundation for marking, displaying, editing, and deleting cut regions.

Output: CutRegion model class and CutController with methods for add, update, delete, and get operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-transcript-navigation/03-01-SUMMARY.md

# Existing code patterns
@src/controllers/transcriptController.js
@src/components/playerController.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CutRegion data model</name>
  <files>src/models/cutRegion.js</files>
  <action>
Create `src/models/cutRegion.js` with a CutRegion class:

```javascript
class CutRegion {
  constructor(id, startTime, endTime = null) {
    this.id = id;           // Unique string ID (e.g., 'cut-1', 'cut-2')
    this.startTime = startTime;  // Start timestamp in seconds
    this.endTime = endTime;      // End timestamp in seconds (null if incomplete)
  }

  isComplete() {
    return this.endTime !== null && this.endTime > this.startTime;
  }

  getDuration() {
    if (!this.isComplete()) return 0;
    return this.endTime - this.startTime;
  }

  containsTime(time) {
    if (!this.isComplete()) return false;
    return time >= this.startTime && time <= this.endTime;
  }

  overlaps(other) {
    if (!this.isComplete() || !other.isComplete()) return false;
    return this.startTime < other.endTime && this.endTime > other.startTime;
  }
}

export default CutRegion;
```

- Model is simple, immutable-friendly (properties can be updated but methods are pure)
- containsTime useful for highlighting segments that fall within a cut region
- overlaps useful for future validation
  </action>
  <verify>File exists at src/models/cutRegion.js with CutRegion class exported as default</verify>
  <done>CutRegion class created with id, startTime, endTime properties and isComplete, getDuration, containsTime, overlaps methods</done>
</task>

<task type="auto">
  <name>Task 2: Create CutController for state management</name>
  <files>src/controllers/cutController.js</files>
  <action>
Create `src/controllers/cutController.js` with CutController class:

```javascript
import CutRegion from '../models/cutRegion.js';

class CutController {
  constructor() {
    this.cutRegions = [];      // Array of CutRegion objects
    this.pendingCut = null;    // CutRegion with only startTime set (awaiting end)
    this.nextId = 1;           // Counter for generating unique IDs

    // Callbacks for UI updates (set externally)
    this.onCutListChanged = null;      // Called when cuts added/removed/modified
    this.onPendingCutChanged = null;   // Called when pending cut state changes
  }

  /**
   * Mark start of a new cut region at the given time
   * @param {number} time - Start timestamp in seconds
   * @returns {CutRegion} - The pending cut region
   */
  markStart(time) {
    // If there's already a pending cut, replace it
    this.pendingCut = new CutRegion(`cut-${this.nextId}`, time);

    if (this.onPendingCutChanged) {
      this.onPendingCutChanged(this.pendingCut);
    }

    return this.pendingCut;
  }

  /**
   * Mark end of the pending cut region
   * @param {number} time - End timestamp in seconds
   * @returns {CutRegion|null} - The completed cut region, or null if no pending cut
   */
  markEnd(time) {
    if (!this.pendingCut) {
      return null;
    }

    // Ensure end > start (swap if needed)
    let startTime = this.pendingCut.startTime;
    let endTime = time;
    if (endTime < startTime) {
      [startTime, endTime] = [endTime, startTime];
    }

    // Complete the cut region
    const completedCut = new CutRegion(this.pendingCut.id, startTime, endTime);
    this.cutRegions.push(completedCut);
    this.nextId++;

    // Clear pending
    this.pendingCut = null;

    // Notify listeners
    if (this.onPendingCutChanged) {
      this.onPendingCutChanged(null);
    }
    if (this.onCutListChanged) {
      this.onCutListChanged(this.cutRegions);
    }

    return completedCut;
  }

  /**
   * Cancel pending cut without completing it
   */
  cancelPending() {
    if (this.pendingCut) {
      this.pendingCut = null;
      if (this.onPendingCutChanged) {
        this.onPendingCutChanged(null);
      }
    }
  }

  /**
   * Update timestamps of an existing cut region
   * @param {string} id - Cut region ID
   * @param {number} startTime - New start time
   * @param {number} endTime - New end time
   * @returns {boolean} - True if update succeeded
   */
  updateCut(id, startTime, endTime) {
    const index = this.cutRegions.findIndex(c => c.id === id);
    if (index === -1) return false;

    // Ensure end > start
    if (endTime <= startTime) return false;

    // Update in place
    this.cutRegions[index] = new CutRegion(id, startTime, endTime);

    if (this.onCutListChanged) {
      this.onCutListChanged(this.cutRegions);
    }

    return true;
  }

  /**
   * Delete a cut region by ID
   * @param {string} id - Cut region ID
   * @returns {boolean} - True if deletion succeeded
   */
  deleteCut(id) {
    const index = this.cutRegions.findIndex(c => c.id === id);
    if (index === -1) return false;

    this.cutRegions.splice(index, 1);

    if (this.onCutListChanged) {
      this.onCutListChanged(this.cutRegions);
    }

    return true;
  }

  /**
   * Get all completed cut regions
   * @returns {CutRegion[]}
   */
  getCutRegions() {
    return [...this.cutRegions];  // Return copy to prevent external mutation
  }

  /**
   * Get pending cut region (if any)
   * @returns {CutRegion|null}
   */
  getPendingCut() {
    return this.pendingCut;
  }

  /**
   * Check if a given time falls within any cut region
   * @param {number} time - Time in seconds
   * @returns {CutRegion|null} - The cut region containing time, or null
   */
  getCutAtTime(time) {
    return this.cutRegions.find(cut => cut.containsTime(time)) || null;
  }

  /**
   * Clear all cut regions
   */
  clearAll() {
    this.cutRegions = [];
    this.pendingCut = null;
    this.nextId = 1;

    if (this.onPendingCutChanged) {
      this.onPendingCutChanged(null);
    }
    if (this.onCutListChanged) {
      this.onCutListChanged([]);
    }
  }
}

export default CutController;
```

Key design decisions:
- Callback pattern matches existing PlayerController.onTimeUpdate
- Pending cut state separate from completed cuts (two-phase marking flow)
- Returns copies from getCutRegions() to prevent external mutation
- Swaps start/end if user marks end before start
  </action>
  <verify>File exists at src/controllers/cutController.js with CutController class exported as default</verify>
  <done>CutController created with markStart, markEnd, updateCut, deleteCut, cancelPending, getCutRegions, getPendingCut, getCutAtTime, clearAll methods and callback properties</done>
</task>

<task type="auto">
  <name>Task 3: Wire CutController into main app</name>
  <files>index.html</files>
  <action>
Update index.html to import and instantiate CutController:

1. Add import statement after existing imports:
```javascript
import CutController from './src/controllers/cutController.js';
```

2. After transcriptController initialization, add:
```javascript
// Initialize CutController
const cutController = new CutController();
```

3. (For now, just instantiate - UI wiring comes in Plan 02)

Also create the models directory:
```bash
mkdir -p src/models
```
  </action>
  <verify>
Run `grep -n "CutController" index.html` shows import and instantiation.
Run `ls src/models/cutRegion.js` confirms model file exists.
  </verify>
  <done>CutController imported and instantiated in index.html, models directory created</done>
</task>

</tasks>

<verification>
1. `ls src/models/cutRegion.js src/controllers/cutController.js` - both files exist
2. `grep "export default" src/models/cutRegion.js src/controllers/cutController.js` - both export classes
3. `grep "CutController" index.html` - imported and instantiated
4. Open browser devtools, no import/syntax errors on page load
</verification>

<success_criteria>
- CutRegion model exists with id, startTime, endTime properties
- CutController manages cut regions with add/update/delete operations
- Two-phase marking (start then end) is supported via pendingCut state
- Callback pattern ready for UI integration in Plan 02
- No errors on page load with new imports
</success_criteria>

<output>
After completion, create `.planning/phases/04-cut-point-management/04-01-SUMMARY.md`
</output>
