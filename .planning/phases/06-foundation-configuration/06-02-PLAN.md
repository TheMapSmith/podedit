---
phase: 06-foundation-configuration
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/services/browserCompatibility.js
  - src/services/fileValidator.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "User sees clear error message if browser lacks WebAssembly support"
    - "User sees clear error message if browser lacks SharedArrayBuffer support"
    - "User sees warning if audio file exceeds 50 MB before processing"
    - "FFmpeg.wasm library loads on demand without SharedArrayBuffer errors"
    - "iOS Safari users see specific warning about single-thread fallback"
  artifacts:
    - path: "src/services/browserCompatibility.js"
      provides: "Browser feature detection and FFmpeg.wasm loader"
      exports: ["BrowserCompatibility"]
    - path: "src/services/fileValidator.js"
      provides: "Extended validation with processing size limit"
      exports: ["validateAudioFile", "validateForProcessing"]
  key_links:
    - from: "src/services/browserCompatibility.js"
      to: "FFmpeg"
      via: "dynamic import from @ffmpeg/ffmpeg"
      pattern: "import.*@ffmpeg/ffmpeg"
    - from: "index.html"
      to: "BrowserCompatibility"
      via: "import and initialization"
      pattern: "BrowserCompatibility"
---

<objective>
Add browser compatibility detection and FFmpeg.wasm lazy loading

Purpose: Before attempting FFmpeg.wasm processing, we must verify the browser supports required features (WebAssembly, SharedArrayBuffer) and warn users about file size limits. FFmpeg.wasm should load on-demand to avoid slowing initial page load.

Output:
- BrowserCompatibility service with feature detection
- Extended file validation for processing size limits
- FFmpeg.wasm lazy loading pattern
- Clear error/warning UI for compatibility issues
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundation-configuration/06-01-SUMMARY.md
@src/services/fileValidator.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BrowserCompatibility service with feature detection</name>
  <files>
    - src/services/browserCompatibility.js
  </files>
  <action>
Create `src/services/browserCompatibility.js` with BrowserCompatibility class:

```javascript
/**
 * BrowserCompatibility - Detects browser features required for FFmpeg.wasm
 */
class BrowserCompatibility {
  constructor() {
    this.ffmpeg = null;
    this.loaded = false;
    this.loadError = null;
  }

  /**
   * Check all required features for FFmpeg.wasm processing
   * @returns {{ supported: boolean, errors: string[], warnings: string[] }}
   */
  checkCompatibility() {
    const errors = [];
    const warnings = [];

    // Check WebAssembly support (required)
    if (typeof WebAssembly === 'undefined') {
      errors.push('WebAssembly is not supported in this browser. Please use a modern browser like Chrome, Firefox, Safari, or Edge.');
    }

    // Check SharedArrayBuffer (required for multi-threading)
    if (typeof SharedArrayBuffer === 'undefined') {
      errors.push('SharedArrayBuffer is not available. This may be due to missing security headers or browser restrictions.');
    }

    // Check crossOriginIsolated (required for SharedArrayBuffer)
    if (!crossOriginIsolated) {
      errors.push('Cross-origin isolation is not enabled. The server must send COOP/COEP headers.');
    }

    // Detect iOS Safari (works but slower - single-thread only)
    const isIOSSafari = this.detectIOSSafari();
    if (isIOSSafari) {
      warnings.push('iOS Safari detected. Audio processing will use single-thread mode and may take 2x longer than desktop browsers.');
    }

    return {
      supported: errors.length === 0,
      errors,
      warnings,
      isIOSSafari
    };
  }

  /**
   * Detect iOS Safari which doesn't support SharedArrayBuffer in Web Workers
   * @returns {boolean}
   */
  detectIOSSafari() {
    const ua = navigator.userAgent;
    const isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
    const isSafari = /Safari/.test(ua) && !/Chrome/.test(ua) && !/CriOS/.test(ua);
    return isIOS && isSafari;
  }

  /**
   * Lazy load FFmpeg.wasm library
   * @param {function} onProgress - Optional progress callback for loading UI
   * @returns {Promise<FFmpeg>}
   */
  async loadFFmpeg(onProgress = null) {
    if (this.loaded && this.ffmpeg) {
      return this.ffmpeg;
    }

    if (this.loadError) {
      throw this.loadError;
    }

    try {
      if (onProgress) onProgress({ stage: 'downloading', progress: 0 });

      // Dynamic import - only loads when called
      const { FFmpeg } = await import('@ffmpeg/ffmpeg');
      const { fetchFile, toBlobURL } = await import('@ffmpeg/util');

      this.ffmpeg = new FFmpeg();

      // Set up progress logging
      this.ffmpeg.on('log', ({ message }) => {
        console.log('[FFmpeg]', message);
      });

      if (onProgress) onProgress({ stage: 'loading', progress: 50 });

      // Load the FFmpeg core (multi-threaded if available)
      // Use toBlobURL to load from CDN with proper CORS handling
      const baseURL = 'https://unpkg.com/@ffmpeg/core-mt@0.12.6/dist/esm';

      await this.ffmpeg.load({
        coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
        wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
        workerURL: await toBlobURL(`${baseURL}/ffmpeg-core.worker.js`, 'text/javascript'),
      });

      if (onProgress) onProgress({ stage: 'ready', progress: 100 });

      this.loaded = true;
      return this.ffmpeg;
    } catch (error) {
      this.loadError = error;
      console.error('Failed to load FFmpeg:', error);
      throw new Error(`Failed to load FFmpeg: ${error.message}`);
    }
  }

  /**
   * Check if FFmpeg is loaded
   * @returns {boolean}
   */
  isLoaded() {
    return this.loaded && this.ffmpeg !== null;
  }

  /**
   * Get the loaded FFmpeg instance
   * @returns {FFmpeg|null}
   */
  getFFmpeg() {
    return this.ffmpeg;
  }
}

export default BrowserCompatibility;
```

Install FFmpeg.wasm packages:
```bash
npm install @ffmpeg/ffmpeg @ffmpeg/util
```

Key design decisions:
- Lazy loading: FFmpeg only loads when loadFFmpeg() is called (not on page load)
- Progress callbacks: UI can show loading state (20MB+ download)
- Error caching: If load fails once, subsequent calls throw cached error
- Multi-thread core: Uses @ffmpeg/core-mt for 2x performance
- CDN loading: Uses toBlobURL to handle CORS properly
  </action>
  <verify>
Test in browser console (after starting dev server):
```javascript
import BrowserCompatibility from './src/services/browserCompatibility.js';
const compat = new BrowserCompatibility();

// Check features
const check = compat.checkCompatibility();
console.log('Supported:', check.supported);
console.log('Errors:', check.errors);
console.log('Warnings:', check.warnings);

// Should show: Supported: true, Errors: [], Warnings: [] (on desktop Chrome)
```

Do NOT test loadFFmpeg() yet - that's for task 3.
  </verify>
  <done>
- BrowserCompatibility service created
- checkCompatibility() correctly detects WebAssembly, SharedArrayBuffer, crossOriginIsolated
- detectIOSSafari() identifies iOS Safari browsers
- FFmpeg packages installed in package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend file validation with processing size limit</name>
  <files>
    - src/services/fileValidator.js
  </files>
  <action>
Extend existing `src/services/fileValidator.js` to add processing-specific validation:

Add new constant:
```javascript
export const MAX_PROCESSING_SIZE = 50 * 1024 * 1024; // 50 MB warning threshold
export const MAX_PROCESSING_SIZE_HARD = 100 * 1024 * 1024; // 100 MB hard limit
```

Add new function:
```javascript
/**
 * Validate file for audio processing (stricter than upload validation)
 * @param {File} file
 * @returns {{ valid: boolean, errors: string[], warnings: string[], fileInfo: object }}
 */
export function validateForProcessing(file) {
  // First run standard validation
  const uploadValidation = validateAudioFile(file);
  if (!uploadValidation.valid) {
    return uploadValidation;
  }

  const warnings = [];
  const errors = [];

  // Soft warning at 50 MB
  if (file.size > MAX_PROCESSING_SIZE) {
    warnings.push(`File is ${formatFileSize(file.size)}. Processing large files may take several minutes and use significant memory.`);
  }

  // Hard limit at 100 MB
  if (file.size > MAX_PROCESSING_SIZE_HARD) {
    errors.push(`File is ${formatFileSize(file.size)} which exceeds the ${formatFileSize(MAX_PROCESSING_SIZE_HARD)} processing limit. Browser memory constraints prevent processing very large files.`);
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    fileInfo: uploadValidation.fileInfo
  };
}
```

Import formatFileSize at top if not already:
```javascript
import { formatFileSize } from '../utils/timeFormat.js';
```

Keep existing validateAudioFile() unchanged - it's still used for initial upload validation.
  </action>
  <verify>
Test in browser console:
```javascript
import { validateForProcessing, MAX_PROCESSING_SIZE } from './src/services/fileValidator.js';

// Create mock files for testing
const small = new File(['x'.repeat(10*1024*1024)], 'small.mp3', { type: 'audio/mpeg' });
const medium = new File(['x'.repeat(60*1024*1024)], 'medium.mp3', { type: 'audio/mpeg' });
const large = new File(['x'.repeat(120*1024*1024)], 'large.mp3', { type: 'audio/mpeg' });

console.log(validateForProcessing(small));   // valid: true, no warnings
console.log(validateForProcessing(medium));  // valid: true, warnings about size
console.log(validateForProcessing(large));   // valid: false, error about limit
```
  </verify>
  <done>
- validateForProcessing() function added
- 50 MB warning threshold triggers warning
- 100 MB hard limit triggers error
- Original validateAudioFile() unchanged
  </done>
</task>

<task type="auto">
  <name>Task 3: Add compatibility check UI and FFmpeg loading test</name>
  <files>
    - index.html
  </files>
  <action>
Update index.html to show compatibility warnings and verify FFmpeg can load:

1. Add CSS for compatibility messages:
```css
.compat-warning {
  margin: 15px 0;
  padding: 12px;
  background: #fff3cd;
  border: 1px solid #ffc107;
  border-radius: 4px;
  color: #856404;
  font-size: 14px;
}

.compat-error {
  margin: 15px 0;
  padding: 12px;
  background: #f8d7da;
  border: 1px solid #dc3545;
  border-radius: 4px;
  color: #721c24;
  font-size: 14px;
}

.processing-status {
  margin: 15px 0;
  padding: 12px;
  background: #e7f3ff;
  border: 1px solid #007bff;
  border-radius: 4px;
  color: #004085;
  font-size: 14px;
}
```

2. Add HTML elements after file-info div (but inside container):
```html
<div id="compat-messages"></div>
<div id="processing-status" class="processing-status" style="display: none;"></div>
```

3. In script module, add:
```javascript
import BrowserCompatibility from './src/services/browserCompatibility.js';
import { validateForProcessing } from './src/services/fileValidator.js';

const browserCompat = new BrowserCompatibility();

// Check compatibility on page load
function checkBrowserCompatibility() {
  const result = browserCompat.checkCompatibility();
  const container = document.getElementById('compat-messages');
  container.innerHTML = '';

  // Show errors (blocking)
  result.errors.forEach(error => {
    const div = document.createElement('div');
    div.className = 'compat-error';
    div.textContent = error;
    container.appendChild(div);
  });

  // Show warnings (informational)
  result.warnings.forEach(warning => {
    const div = document.createElement('div');
    div.className = 'compat-warning';
    div.textContent = warning;
    container.appendChild(div);
  });

  return result.supported;
}

// Run on load
const isCompatible = checkBrowserCompatibility();
```

4. Add "Test FFmpeg" button (temporary, for verification - can remove after phase):
```html
<button id="test-ffmpeg-btn" style="margin-top: 10px;">Test FFmpeg Loading</button>
```

Wire up the test button:
```javascript
document.getElementById('test-ffmpeg-btn').addEventListener('click', async () => {
  const statusDiv = document.getElementById('processing-status');
  statusDiv.style.display = 'block';
  statusDiv.textContent = 'Loading FFmpeg... (this may take 10-30 seconds on first load)';

  try {
    await browserCompat.loadFFmpeg((progress) => {
      statusDiv.textContent = `Loading FFmpeg: ${progress.stage} (${progress.progress}%)`;
    });
    statusDiv.textContent = 'FFmpeg loaded successfully! Ready for audio processing.';
    statusDiv.style.background = '#d4edda';
    statusDiv.style.borderColor = '#28a745';
    statusDiv.style.color = '#155724';
  } catch (error) {
    statusDiv.textContent = `Failed to load FFmpeg: ${error.message}`;
    statusDiv.style.background = '#f8d7da';
    statusDiv.style.borderColor = '#dc3545';
    statusDiv.style.color = '#721c24';
  }
});
```

5. Update file input handler to show processing warnings:
In the existing file change handler, after successful validation, add:
```javascript
// Check processing limits (warning only at this stage)
const processingValidation = validateForProcessing(file);
if (processingValidation.warnings.length > 0) {
  const container = document.getElementById('compat-messages');
  processingValidation.warnings.forEach(warning => {
    const div = document.createElement('div');
    div.className = 'compat-warning';
    div.textContent = warning;
    container.appendChild(div);
  });
}
```
  </action>
  <verify>
Manual test workflow:
1. npm run dev
2. Open http://localhost:5173
3. Page loads - no compatibility errors shown (on supported browser)
4. Click "Test FFmpeg Loading" button
5. See loading progress messages
6. After 10-30 seconds, see "FFmpeg loaded successfully"
7. Load a large audio file (>50 MB if available) - see size warning
8. Load an audio file >100 MB (create with `dd if=/dev/zero of=test.mp3 bs=1M count=110`) - see error

Test on iOS Safari (via BrowserStack or real device):
- Should see single-thread warning
  </verify>
  <done>
- Compatibility messages display on page load
- Errors block processing, warnings inform user
- Test FFmpeg button successfully loads FFmpeg.wasm
- File size warnings appear for files >50 MB
- File size errors appear for files >100 MB
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify complete Phase 6 success criteria:

1. Vite dev server running (from Plan 01)
2. Cross-origin isolation active (from Plan 01)
3. Browser compatibility detection working:
   - On Chrome/Firefox/Edge: no errors
   - On iOS Safari: single-thread warning
   - On old browser: WebAssembly error

4. FFmpeg.wasm loads successfully:
   - Click "Test FFmpeg Loading"
   - Wait for loading to complete
   - See success message

5. File size validation:
   - File <50 MB: no warning
   - File 50-100 MB: warning shown
   - File >100 MB: error, can't proceed to processing
</verification>

<success_criteria>
- BrowserCompatibility service detects required features
- Clear error messages for unsupported browsers
- Clear warnings for iOS Safari (single-thread mode)
- FFmpeg.wasm lazy loads on demand without errors
- File size warnings appear at 50 MB threshold
- File size errors appear at 100 MB threshold
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation-configuration/06-02-SUMMARY.md`

Document:
- Browser compatibility detection results on tested browsers
- FFmpeg.wasm loading time observations
- Any issues encountered and resolutions
</output>
