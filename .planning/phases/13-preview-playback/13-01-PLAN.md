---
phase: 13-preview-playback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
autonomous: false

must_haves:
  truths:
    - "User can enable preview mode and audio automatically skips all marked cut regions during playback"
    - "User clicks word inside cut region and playback seeks to end of that cut region"
    - "Preview mode handles overlapping/adjacent cuts without infinite loops or skipped content"
    - "User sees visual indicator showing preview mode is active"
    - "Preview mode updates dynamically when user adds or removes cuts during playback"
  artifacts:
    - path: "index.html"
      provides: "PreviewController class with skip state machine"
      contains: "class PreviewController"
      min_lines: 100
    - path: "index.html"
      provides: "Preview mode toggle button with visual indicator"
      contains: "<button id=\"toggle-preview-btn\""
    - path: "index.html"
      provides: "PreviewController initialization and wiring"
      contains: "const previewController = new PreviewController"
  key_links:
    - from: "PlayerController.onTimeUpdate"
      to: "PreviewController.onTimeUpdate"
      via: "callback wiring in initialization"
      pattern: "playerController\\.onTimeUpdate.*previewController"
    - from: "CutController.onCutListChanged"
      to: "PreviewController.onCutListChanged"
      via: "callback wiring in initialization"
      pattern: "cutController\\.onCutListChanged.*previewController"
    - from: "PreviewController.skipToTime"
      to: "audioService.seek"
      via: "skip logic calls AudioService.seek()"
      pattern: "this\\.audioService\\.seek"
    - from: "toggle-preview-btn click"
      to: "PreviewController.togglePreview"
      via: "event listener"
      pattern: "toggle-preview-btn.*addEventListener.*togglePreview"
---

<objective>
Implement preview playback mode that automatically skips cut regions to match final exported audio.

Purpose: Allows users to hear what the final edited podcast will sound like before processing, validating cut decisions in real-time.

Output:
- PreviewController class managing skip state machine
- Toggle button with visual indicator for preview mode
- Full integration with PlayerController and CutController for dynamic synchronization
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/11-cut-region-visual-highlighting/11-01-SUMMARY.md
@.planning/phases/12-transcript-search/12-01-SUMMARY.md
@src/components/playerController.js
@src/controllers/cutController.js
@src/controllers/transcriptController.js
@src/services/audioService.js
@src/models/cutRegion.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PreviewController class with skip state machine</name>
  <files>index.html</files>
  <action>
Create PreviewController class in index.html script section with the following implementation:

**Class structure:**
```javascript
class PreviewController {
  constructor(audioService, cutController) {
    this.audioService = audioService;
    this.cutController = cutController;
    this.enabled = false;           // Preview mode state
    this.lastSkipTime = -1;         // Prevent infinite loop
    this.skipTolerance = 0.15;      // VBR MP3 seek tolerance (150ms)
  }

  togglePreview() { /* enable/disable preview mode */ }
  onTimeUpdate(currentTime) { /* check if in cut, skip if needed */ }
  onCutListChanged(cutRegions) { /* update internal state */ }
  skipToTime(time) { /* seek with loop prevention */ }
  findNextNonCutTime(currentTime) { /* find safe seek target */ }
}
```

**Skip logic requirements:**
1. **onTimeUpdate callback**: Called at 60fps from PlayerController
   - Check if currentTime falls within any cut region using cutController.getCutAtTime()
   - If in cut AND enabled: call skipToTime(cut.endTime)
   - Track lastSkipTime to prevent infinite loops (don't skip if |currentTime - lastSkipTime| < skipTolerance)

2. **Handle overlapping/adjacent cuts**:
   - findNextNonCutTime() method: Given currentTime, find next time NOT in any cut region
   - Start from cut.endTime, check if that time is in another cut
   - If yes, recursively find end of that cut
   - Return first safe time outside all cuts

3. **VBR MP3 tolerance**:
   - Use skipTolerance = 0.15s (150ms) as buffer
   - Don't skip again if seek landed within tolerance of previous skip
   - Prevents rapid re-seeking on imprecise VBR files

4. **State synchronization**:
   - onCutListChanged: No action needed, cutController is already up-to-date
   - Use cutController.getCutRegions() to iterate through cuts when needed

**Why avoid infinite loops**:
- VBR MP3 files have imprecise seeking (audioService.seek(10.0) may land at 9.95 or 10.05)
- Without lastSkipTime tracking, PreviewController could detect "still in cut" and skip again infinitely
- 150ms tolerance validated in STATE.md blockers/concerns

**Integration points**:
- audioService: Use seek() method to skip
- cutController: Use getCutAtTime(time) and getCutRegions() for cut detection
  </action>
  <verify>
Read index.html and confirm:
- PreviewController class exists with all required methods
- Skip logic includes loop prevention with lastSkipTime tracking
- findNextNonCutTime handles overlapping/adjacent cuts
- Constructor accepts audioService and cutController parameters
  </verify>
  <done>PreviewController class implemented with skip state machine, loop prevention, and VBR tolerance handling</done>
</task>

<task type="auto">
  <name>Task 2: Add preview mode toggle button and visual indicator</name>
  <files>index.html</files>
  <action>
Add preview mode UI to player controls section in index.html:

**Button placement**: After existing player controls (play button, seek slider), before transcript section

**HTML structure**:
```html
<div class="preview-mode-container">
  <button id="toggle-preview-btn" class="utility-button">
    Preview Mode: OFF
  </button>
  <span id="preview-indicator" class="preview-indicator hidden">
    ðŸŽ§ Skipping cuts
  </span>
</div>
```

**CSS styling**:
```css
.preview-mode-container {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-top: 12px;
}

.preview-indicator {
  font-size: 14px;
  color: var(--accent-primary);
  font-weight: 500;
}

.preview-indicator.hidden {
  display: none;
}

/* Active state styling for toggle button */
#toggle-preview-btn.active {
  background: var(--accent-primary);
  color: var(--bg-primary);
  border-color: var(--accent-primary);
}
```

**Button interaction**:
- Wire click event to PreviewController.togglePreview()
- Update button text: "Preview Mode: OFF" / "Preview Mode: ON"
- Add/remove .active class on button
- Show/hide preview-indicator span based on preview mode state

**Visual feedback**:
- Button uses existing dark theme button styles (from Phase 11)
- .active state uses accent color for clear visual distinction
- Indicator only visible when preview mode is ON
- Emoji (ðŸŽ§) provides quick visual reference for active mode

**Why this design**:
- Toggle button pattern familiar from audio editors (solo/mute toggles)
- Clear text label removes ambiguity about current state
- Indicator reinforces that skip behavior is active during playback
- Uses CSS Custom Properties from Phase 10 for theme consistency
  </action>
  <verify>
Read index.html and confirm:
- Preview mode container with toggle button and indicator exists
- CSS styles for .preview-mode-container, .preview-indicator, #toggle-preview-btn.active defined
- Button text clearly indicates OFF/ON state
- Indicator text describes skip behavior
  </verify>
  <done>Preview mode UI added with toggle button showing clear state and visual indicator for active mode</done>
</task>

<task type="auto">
  <name>Task 3: Wire PreviewController to PlayerController and CutController</name>
  <files>index.html</files>
  <action>
Wire PreviewController into application initialization in index.html:

**Initialization order** (in main script section):
1. After audioService, cutController, playerController initialization
2. Before existing callback wirings

**PreviewController instantiation**:
```javascript
// Create preview controller
const previewController = new PreviewController(audioService, cutController);
```

**Wire to PlayerController.onTimeUpdate**:
```javascript
// Chain preview controller into PlayerController time updates
// Existing: playerController.onTimeUpdate = (time) => transcriptController.onTimeUpdate(time)
// Update to:
playerController.onTimeUpdate = (time) => {
  transcriptController.onTimeUpdate(time);
  if (previewController.enabled) {
    previewController.onTimeUpdate(time);
  }
};
```

**Wire to CutController.onCutListChanged**:
```javascript
// Existing: cutController.onCutListChanged = (cuts) => { transcriptController.highlightCutRegions(cuts); }
// Update to:
cutController.onCutListChanged = (cuts) => {
  transcriptController.highlightCutRegions(cuts);
  if (previewController.enabled) {
    previewController.onCutListChanged(cuts);
  }
};
```

**Wire toggle button**:
```javascript
const togglePreviewBtn = document.getElementById('toggle-preview-btn');
const previewIndicator = document.getElementById('preview-indicator');

togglePreviewBtn.addEventListener('click', () => {
  previewController.togglePreview();

  // Update UI
  if (previewController.enabled) {
    togglePreviewBtn.textContent = 'Preview Mode: ON';
    togglePreviewBtn.classList.add('active');
    previewIndicator.classList.remove('hidden');
  } else {
    togglePreviewBtn.textContent = 'Preview Mode: OFF';
    togglePreviewBtn.classList.remove('active');
    previewIndicator.classList.add('hidden');
  }
});
```

**Why this approach**:
- Conditional checks (if previewController.enabled) prevent unnecessary processing when preview mode is OFF
- Chaining into existing onTimeUpdate callback preserves transcript highlighting
- Toggle button updates UI synchronously with state change
- PreviewController has no external dependencies beyond audioService and cutController

**Integration validation**:
- PreviewController receives time updates at 60fps during playback when enabled
- PreviewController receives cut list updates when user marks/deletes cuts
- Button state reflects PreviewController.enabled state
- Indicator visibility synchronized with preview mode state
  </action>
  <verify>
Read index.html and confirm:
- PreviewController instantiated after audioService, cutController, playerController
- playerController.onTimeUpdate chains transcriptController and previewController calls
- cutController.onCutListChanged chains transcriptController and previewController calls
- toggle-preview-btn click listener wired to update button text, class, and indicator visibility
  </verify>
  <done>PreviewController fully integrated with PlayerController and CutController, toggle button wired with UI state updates</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Preview playback mode with automatic cut region skipping and visual indicator
  </what-built>
  <how-to-verify>
1. **Load test audio**: Upload audio file and generate transcript
2. **Mark test cuts**: Create 2-3 cut regions at different timestamps (e.g., 0:10-0:15, 0:30-0:35)
3. **Enable preview mode**: Click "Preview Mode: OFF" button (should toggle to "ON" with active styling)
4. **Test automatic skip**:
   - Click play button
   - Observe playback automatically skip over marked cut regions
   - Verify "ðŸŽ§ Skipping cuts" indicator visible during playback
5. **Test click-to-seek in cut**:
   - Click word inside a cut region
   - Verify playback seeks to end of that cut region (not inside cut)
6. **Test overlapping cuts** (if supported by UI):
   - Mark two adjacent/overlapping cuts (e.g., 0:20-0:25, 0:24-0:30)
   - Play through region
   - Verify skips to 0:30 (end of second cut), not stuck in loop
7. **Test dynamic updates**:
   - While preview mode ON and playing, mark a new cut ahead of playhead
   - Verify new cut is skipped when playhead reaches it
   - Delete a cut and verify playback no longer skips that region
8. **Test disable preview**:
   - Click "Preview Mode: ON" button (should toggle to "OFF")
   - Play through cut regions
   - Verify playback does NOT skip cuts (normal behavior)
   - Verify indicator hidden
9. **Test edge cases**:
   - Seek manually while in preview mode (should still skip if landing in cut)
   - Rapid play/pause/seek (should not cause infinite loops or crashes)
   - Multiple cuts in rapid succession (should skip all correctly)

**Expected behavior:**
- Automatic skip feels seamless (no noticeable lag)
- Click-to-seek in cut lands at cut end, not mid-cut
- No infinite loops or audio stuttering
- UI state (button text, active class, indicator) always matches preview mode state
- Works with any number of cuts (0, 1, many)

**Known VBR tolerance**: Skip may land 0.1-0.2s before/after cut boundary due to VBR MP3 encoding. This is acceptable and documented in STATE.md.
  </how-to-verify>
  <resume-signal>
Type "approved" if preview mode works as expected, or describe any issues with skip behavior, infinite loops, or UI state synchronization.
  </resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **PreviewController class exists**:
   - `grep -A 20 "class PreviewController" index.html` shows complete implementation
   - Methods: constructor, togglePreview, onTimeUpdate, skipToTime, findNextNonCutTime

2. **Skip logic includes loop prevention**:
   - `grep "lastSkipTime" index.html` shows tracking variable
   - `grep "skipTolerance" index.html` shows VBR tolerance buffer

3. **UI elements present**:
   - `grep "toggle-preview-btn" index.html` shows button with ID
   - `grep "preview-indicator" index.html` shows indicator span
   - `grep ".preview-mode-container" index.html` shows CSS styling

4. **Integration wiring**:
   - `grep "previewController.onTimeUpdate" index.html` shows PlayerController callback chain
   - `grep "previewController.onCutListChanged" index.html` shows CutController callback chain
   - `grep "previewController.togglePreview" index.html` shows button event listener

5. **Requirements coverage**:
   - NAV-05: Automatic skip logic in onTimeUpdate âœ“
   - NAV-06: Click-to-seek handled by TranscriptController (existing), PreviewController detects and skips âœ“
   - NAV-07: findNextNonCutTime handles overlapping/adjacent cuts âœ“
   - NAV-08: Visual indicator visible when preview mode enabled âœ“
</verification>

<success_criteria>
Preview playback mode complete when:
- [ ] User can enable preview mode via toggle button
- [ ] Audio automatically skips all marked cut regions during playback
- [ ] Click-to-seek in cut region seeks to end of cut (not inside)
- [ ] Overlapping/adjacent cuts handled without infinite loops
- [ ] Visual indicator shows preview mode active state
- [ ] Preview mode updates dynamically when cuts added/removed during playback
- [ ] Toggle button clearly indicates OFF/ON state with visual styling
- [ ] No audio stuttering or playback artifacts from skip logic
- [ ] All 4 Phase 13 requirements (NAV-05 through NAV-08) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/13-preview-playback/13-01-SUMMARY.md` following the summary template.

Include:
- PreviewController implementation details (skip logic, loop prevention, VBR tolerance)
- Skip state machine behavior (how overlapping cuts are handled)
- Integration points with PlayerController and CutController
- UI state synchronization approach
- Edge cases tested and validated
- Any VBR seek imprecision observations
- Performance notes (impact of 60fps time update checks)
</output>
